package homework2;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;


/**
 * A Graph is an abstraction for a mathematical graph with sets of <i>Nodes</i> and <i>Edges</i>.
 * Graphs are immutable.
 * <p>
 * <b>Generics:</b>
 * 	<pre>
 * NODE_T: the class used for the nodes.
 * 	</pre>
 * <b>The following fields are used in the specification:</b>
 * <pre>
 *   Nodes : sequence              // 
 * </pre>
 * </p>
 * 
 * @author yoavg
 *
 */
public final class Graph<NODE_T> {
	/**
	 * Abstraction function
	 * <pre>
	 * nodes : ArrayList	//	the list of Nodes present in the graph
	 * and edge between n1 and n2 is represented by the presence of n2 in n1.children
	 * </pre>
	 * Representation invariant
	 * <pre>
	 * for each node, node.children does not contain duplicate nodes
	 * </pre>
	 */
	private final Map<Node, NODE_T> nodes;
	private final String name;
	
	/**
	 * The Node class acts as a wrapper for an object of type NODE_T.
	 * Node is immutable.
	 * @author yoavg
	 *
	 */
	private final class Node {
		
		private final NODE_T node;
		private final Set<NODE_T> children;
		
		/**
		 * Construct a new Node
		 * @requires node != null
		 * @effects Construct a new node, n, such that:
		 * 			n.node = node and n.children is empty
		 * 
		 */
		public Node(NODE_T node) {
			this.node = node;
			this.children = new HashSet<>();
		}
		
		/**
		 * TODO: delete if redundant
		 * @effects Returns a copy of this.
		 */
		public NODE_T getNode() {
			return this.node;
		}
		
		/**
		 * @return Returns an Iterator of this node's children
		 */
		public Iterator<NODE_T> getChildren() {
			@SuppressWarnings("unchecked")
			Set<NODE_T> clone = (Set<NODE_T>) ((HashSet<NODE_T>) this.children).clone();
			return clone.iterator();
		}
		
		/**
		 * @requires child != null
		 * @modifies this
		 * @effects append a <b>copy</b> of child into this.children
		 */
		public void addChild(NODE_T child) {
			this.children.add(node);
		}
		
		/**
		 * Compares the specified Object with this Node for equality.
		 * @effects Returns true iff o equals this.node
		 */
		public boolean equals(Object obj) {
			return this.node.equals(obj);
		}
		
		/**
		 * @effects Returns hash code for this
		 */
		public int hashCode() {
			return this.node.hashCode();
		}
	}
	
	/**
	 * Constructor for Graph
	 * @requires name != null && name != ""
	 * @effects Construct a new Graph g with g.name=name && g.nodes is empty
	 */
	public Graph(String name) {
		this.name = name;
		this.nodes = new HashMap<>();
	}
	
	/**
	 * @effects Returns this.name
	 */
	public String getName() {
		return this.name;
	}
	
	/**
	 * Returns an iterator for all nodes in graph
	 * @effects Returns an iterator for all nodes in graph
	 */
	public Iterator<NODE_T> getNodes() {
		@SuppressWarnings("unchecked")
		ArrayList<NODE_T> values = (ArrayList<NODE_T>) ((HashMap<Node,NODE_T>) this.nodes).values();
		return values.iterator();
	}
	
	/**
	 * @requires node != null
	 * @effects Return an Iterator for node.children
	 */
	public Iterator<NODE_T> getChildren(NODE_T node) {
		Node n = new Node(node);
		return n.getChildren();
	}
	
	/**
	 * @requires node != null
	 * @modifies this
	 * @effects adds node to this.nodes 
	 */
	public void addNode(NODE_T node) {
		
	}
	
	/**
	 * @requires source_node != null && destination_node != null && destination_node is not in source_node.children
	 * @modifies source_node
	 * @effects adds destination_node to source_node.children
	 */
	public void addEdge(NODE_T source_node, NODE_T destination_node) {
		
	}
	
	/**
	 * Compares the specified Object with this Graph for equality.
	 * @effects Returns true iff o is an instance of Graph &&
	 * 						this.name = o.name
	 */
	public boolean equals(Object o) {
		
	}
	
	/**
	 * @effects Returns hash code for this
	 */
	public int hashCode() {
		
	}
	
	/**
	 * @effects Returns a string representation of this.
	 * @param name
	 */
	public String toString() {
		
	}
	
	/**
	 * Checks to see if the representation invariant is being violated.
	 * @effects Throws AssertionError if representation invariant is violated.
	 */
	private void checkRep() {
		
	}
}
